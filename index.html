<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="week-2---literature-review" class="level1">
<h1>WEEK 2 - LITERATURE REVIEW</h1>
<section id="a-systematic-review-of-clinical-health-conditions-predicted-by-machine-learning-diagnostic-and-prognostic-models-trained-or-validated-using-real-world-primary-health-care-data" class="level2">
<h2 class="anchored" data-anchor-id="a-systematic-review-of-clinical-health-conditions-predicted-by-machine-learning-diagnostic-and-prognostic-models-trained-or-validated-using-real-world-primary-health-care-data">A systematic review of clinical health conditions predicted by machine learning diagnostic and prognostic models trained or validated using real-world primary health care data</h2>
<section id="background-motivation" class="level3">
<h3 class="anchored" data-anchor-id="background-motivation">BACKGROUND / MOTIVATION :</h3>
<p>The integration of machine learning (ML) into healthcare has been one of the most significant developments of the past decade. As healthcare systems generate massive amounts of electronic health records (EHRs), insurance claims data, and wearable sensor data, there is an increasing interest in using ML models for disease prediction, risk stratification, and prognosis.</p>
<p>However, most prior ML research has relied heavily on hospital datasets or controlled trial data. These data sources, while high quality, do not capture the everyday experiences of patients in primary health care (PHC), where most chronic conditions such as diabetes, hypertension, and cardiovascular disease are first diagnosed and managed. This creates a major gap: if ML models are trained primarily on tertiary hospital data, they may not generalize to real-world PHC environments.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/clipboard-2850644566.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>The significance of Abdulazeem et al.’s (2023) paper lies in its systematic review of studies that specifically trained or validated ML models using PHC data. By analyzing 106 studies covering more than 24 million participants, the authors shed light on both the progress and shortcomings of ML in real-world disease management. This is crucial as healthcare moves toward more personalized, predictive, and preventive approaches.</p>
</section>
<section id="methods-used" class="level3">
<h3 class="anchored" data-anchor-id="methods-used">METHODS USED</h3>
<p>The authors employed a systematic review methodology following PRISMA (Preferred Reporting Items for Systematic Reviews and Meta-Analyses) guidelines, ensuring transparency and replicability. They searched multiple databases including PubMed, Cochrane, Elsevier, Web of Science, IEEE Xplore, ACM, and preprint servers such as bioRxiv.</p>
<p>This broad search strategy ensured the inclusion of both clinical and computational literature. Inclusion criteria required that studies must use real-world PHC data and apply ML models for either diagnostic or prognostic purposes. Exclusion criteria filtered out simulation-only studies and those using purely hospital datasets. The final pool of 106 eligible studies spanned 42 health conditions, with 207 unique ML models evaluated. The authors categorized the studies by disease type (e.g., diabetes, Alzheimer’s, cardiovascular), by model type (e.g., logistic regression, random forests, support vector machines, neural networks), and by validation strategy (internal cross-validation vs.&nbsp;external validation).</p>
<p>A major methodological innovation was the use of the PROBAST tool (Prediction model Risk Of Bias Assessment Tool) to evaluate the methodological quality of the included studies. This allowed the authors to move beyond reporting performance metrics to critically assess generalizability and potential bias.</p>
<p><strong>Performance Metrics</strong></p>
<p>Accuracy:<br>
<span class="math display">\[ Accuracy = \frac{TP + TN}{TP + TN + FP + FN} \]</span></p>
<p>Precision (Positive Predictive Value):<br>
<span class="math display">\[ Precision = \frac{TP}{TP + FP} \]</span></p>
<p>Recall (Sensitivity):<br>
<span class="math display">\[ Recall = \frac{TP}{TP + FN} \]</span></p>
<p>Specificity:<br>
<span class="math display">\[ Specificity = \frac{TN}{TN + FP} \]</span></p>
<p>F1 Score:<br>
<span class="math display">\[ F_1 = 2 \times \frac{Precision \times Recall}{Precision + Recall} \]</span></p>
<p>AUROC (Area Under ROC Curve):<br>
<span class="math display">\[ AUROC = \int_{0}^{1} TPR(FPR^{-1}(x)) \, dx \]</span></p>
<hr>
<p><strong>Cross-Validation Performance Estimate</strong></p>
<p><span class="math display">\[ \hat{E}_{CV} = \frac{1}{k} \sum_{i=1}^{k} E_i \]</span></p>
<hr>
<p><strong>PROBAST Risk of Bias Scoring</strong></p>
<p><span class="math display">\[ RiskScore = \sum_{j=1}^{m} w_j \cdot I(bias_j) \]</span></p>
<p>where<br>
- (m) = number of bias domains (participants, predictors, outcomes, analysis)<br>
- (I(bias_j)) = indicator if bias present<br>
- (w_j) = weight for domain (j)</p>
</section>
<section id="significance-of-the-work" class="level3">
<h3 class="anchored" data-anchor-id="significance-of-the-work">SIGNIFICANCE OF THE WORK</h3>
<p>The findings of the review are highly significant. Diabetes mellitus was the most frequently studied health condition (21 studies, 19.8%), followed by Alzheimer’s disease (12 studies, 11.3%), cardiovascular diseases (9 studies, 8.5%), hypertension (7 studies, 6.6%), and chronic respiratory diseases (6 studies, 5.7%). These patterns reflect the global burden of chronic diseases in PHC. In terms of methodology, logistic regression and random forests remained the most widely used models, but there was also significant exploration of support vector machines, gradient boosting, and deep neural networks. Importantly, while many models demonstrated promising predictive accuracy (AUROC scores often above 0.80), the majority of studies lacked external validation, limiting their applicability in practice. One of the most striking findings was that 90.8% of the included studies were judged to be at high or unclear risk of bias. This suggests that although ML shows potential in PHC, methodological weaknesses currently limit its clinical utility. The review underscores the urgent need for more robust validation and fairness-aware algorithms to ensure equitable deployment.</p>
</section>
<section id="connection-to-work" class="level3">
<h3 class="anchored" data-anchor-id="connection-to-work">CONNECTION TO WORK</h3>
<p>This paper builds upon and differs from previous literature in meaningful ways. Earlier reviews on ML in healthcare primarily focused on hospital-based EHRs or specific disease categories. For example, prior systematic reviews often limited their scope to oncology or cardiology, overlooking the diversity of conditions seen in PHC. By contrast, Abdulazeem et al.&nbsp;(2023) covered 42 different conditions, offering a broader view. The study also connects with the growing body of literature on real-world evidence (RWE). Regulatory bodies such as the U.S. FDA and EMA have increasingly acknowledged the role of RWE in medical decision-making. By demonstrating both the potential and pitfalls of ML applied to RWE in PHC, this review provides critical context for policymakers and regulators. The authors cited several seminal works on fairness, interpretability, and ethics in ML, highlighting frameworks such as SHAP and LIME for model interpretability. This positions their review not just as a catalog of studies but as a roadmap linking technical, clinical, and ethical perspectives.</p>
</section>
<section id="relevance-to-capstone-project" class="level3">
<h3 class="anchored" data-anchor-id="relevance-to-capstone-project">RELEVANCE TO CAPSTONE PROJECT</h3>
<p>The paper is directly relevant to the anticipated capstone project, which also aims to explore machine learning applications in disease prediction and management using real-world data. Several aspects of this study inform the capstone design:</p>
<ol type="1">
<li><p>It highlights commonly used algorithms (logistic regression, random forests, neural networks) that could be applied to capstone datasets.</p></li>
<li><p>It identifies limitations (lack of external validation, bias, interpretability issues) that the capstone project can aim to address.</p></li>
<li><p>It emphasizes the importance of chronic conditions such as diabetes and cardiovascular disease, which may align with the capstone’s focus areas.</p></li>
<li><p>It demonstrates the value of rigorous evaluation frameworks (AUROC, sensitivity, specificity, PROBAST) that the capstone can adopt.</p></li>
</ol>
<p>By incorporating these insights, the capstone project could contribute by developing more interpretable models, integrating fairness constraints, or validating models across diverse patient subgroups. This would build upon the gaps identified in Abdulazeem et al.&nbsp;(2023) while moving the field forward.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">REFERENCES</h3>
<ol type="1">
<li>Abdulazeem, H., Whitelaw, S., Schauberger, G., &amp; Klug, S. J. (2023). A systematic review of clinical health conditions predicted by machine learning diagnostic and prognostic models trained or validated using real-world primary health care data. PLOS ONE, 18(9), e0274276. https://doi.org/10.1371/journal.pone.0274276</li>
<li>Klonoff DC. The expanding role of real-world evidence trials in health care decision making. J Diabetes Sci Technol. Jan 2020;14(1):174-179. [FREE Full text] [doi: 10.1177/1932296819832653] [Medline: 30841738]</li>
<li>Junaid SB, Imam AA, Balogun AO, De Silva LC, Surakat Y A, Kumar G, et al.&nbsp;Recent advancements in emerging technologies for healthcare management systems: a survey. Healthcare (Basel). Oct 03, 2022;10(10):1940. [FREE Full text] [doi: 10.3390/healthcare10101940] [Medline: 36292387]</li>
<li>Williamson SM, Prybutok V . Balancing privacy and progress: a review of privacy challenges, systemic oversight, and</li>
</ol>
<div data-align="right">
<p>Madhu Kiran Reddy Koduru</p>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>