<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="week-1---literature-review" class="level1">
<h1>WEEK 1 - LITERATURE REVIEW</h1>
<section id="machine-learning-for-analyzing-real-world-data-in-disease-prediction-and-management" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning-for-analyzing-real-world-data-in-disease-prediction-and-management">Machine Learning for Analyzing Real-World Data in Disease Prediction and Management</h2>
<section id="background-motivation" class="level3">
<h3 class="anchored" data-anchor-id="background-motivation">BACKGROUND / MOTIVATION :</h3>
<p>The integration of machine learning (ML) with real-world data (RWD) has emerged as one of the most transformative developments in modern healthcare. Traditional clinical trials, while regarded as the gold standard for evaluating interventions, are inherently limited by their controlled settings, strict eligibility criteria, and relatively small sample sizes. In contrast, RWD—derived from electronic health records (EHRs), patient registries, claims data, and increasingly wearable health devices—captures patient experiences in routine care. This makes it more representative of diverse populations and thus more relevant for informing clinical practice. The reviewed article situates itself in this context, recognizing that the healthcare industry is experiencing an urgent demand for predictive and personalized solutions driven by the exponential growth of healthcare data.</p>
<p>. The central problem identified in the paper lies in the gap between the availability of massive, heterogeneous health datasets and the effective use of these datasets for disease prediction and management. While ML algorithms have shown potential in controlled research contexts, their application to messy, incomplete, and unstandardized RWD remains underexplored. Moreover, the integration of ML into real-world clinical workflows is hindered by challenges such as poor data quality, lack of model interpretability, limited generalizability, and ethical concerns regarding privacy and bias.</p>
<p>. This systematic review attempts to address this gap by synthesizing evidence from recent clinical trials and cohort studies (2014–2024) that applied ML to RWD. In doing so, it seeks to identify both the progress and persistent obstacles in this evolving field. The significance of the research question is multifold. First, the global burden of chronic diseases such as cardiovascular disease, diabetes, and cancer demands more effective predictive tools to enable earlier diagnosis and intervention. ML applied to RWD can potentially stratify patients by risk, tailor treatments to individuals, and improve overall health outcomes. Second, healthcare systems worldwide are under increasing strain from rising costs and aging populations. Efficient predictive modeling can reduce unnecessary interventions, optimize resource allocation, and improve cost-effectiveness. Finally, regulators such as the U.S. Food and Drug Administration (FDA) and the European Medicines Agency (EMA) are beginning to formally recognize the role of real-world evidence (RWE) in evaluating therapies. This raises the stakes for ensuring that ML-driven insights derived from RWD are robust, interpretable, and ethically sound.</p>
<p>In sum, the paper positions itself at the intersection of urgent healthcare challenges and technological opportunity. By systematically reviewing the landscape of ML applications to RWD, the authors aim not only to catalog methodological advances but also to spotlight critical barriers—particularly data quality, fairness, and regulatory frameworks—that must be addressed to unlock the full potential of ML in precision medicine and healthcare management.</p>
</section>
<section id="methods-used" class="level3">
<h3 class="anchored" data-anchor-id="methods-used">METHODS USED</h3>
<p>The review followed the PRISMA (Preferred Reporting Items for Systematic Reviews and Meta-Analyses) guidelines, ensuring methodological rigor and transparency. The authors applied clear inclusion and exclusion criteria to focus on clinical trials and cohort studies that employed ML techniques on real-world health data for disease prediction or management.</p>
<p>Importantly, the scope was deliberately limited to peer-reviewed studies in English published between 2014 and 2024, reflecting the most recent advances in both ML and healthcare analytics. The information sources included major biomedical and clinical databases such as PubMed, Scopus, Web of Science, and the Cochrane Library. To capture gray literature, Google Scholar was also searched, and manual reference checks were performed. This multi-source approach increased the comprehensiveness of the review. The search strategy was carefully constructed with Boolean operators and Medical Subject Headings (MeSH), combining terms related to ML (“machine learning,” “deep learning,” “artificial intelligence”), clinical study designs (“randomized controlled trial,” “pragmatic trial,” “cohort study”), and healthcare outcomes (“disease prediction,” “management,” “outcomes”).</p>
<p><strong>Logistic regression</strong>: <span class="math display">\[
P(y=1|x) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \dots + \beta_p x_p)}}
\]</span></p>
<p><span class="math display">\[
\hat{y} =
\begin{cases}
1 &amp; \text{if } P(y=1|x) \geq 0.5 \\
0 &amp; \text{otherwise}
\end{cases}
\]</span> <strong>Support Vector Machine</strong>: <span class="math display">\[
f(x) = \text{sign}(w^T x + b)
\]</span></p>
<p><span class="math display">\[
\min_{w, b} \; \frac{1}{2} \|w\|^2 \quad \text{s.t.} \quad y_i (w^T x_i + b) \geq 1 \; \forall i
\]</span></p>
<p><span class="math display">\[
\min_{w, b, \xi} \; \frac{1}{2} \|w\|^2 + C \sum_i \xi_i
\]</span></p>
<p>The study selection process was conducted in two stages: initial title and abstract screening, followed by full-text review by independent reviewers. Discrepancies were resolved through discussion and, when necessary, a third reviewer. This rigorous screening reduced the initial pool of over 11,000 records to 57 eligible studies. Data extraction was standardized and included study design, disease category, type of RWD, ML methodology, performance metrics (e.g., accuracy, sensitivity, specificity, AUROC), and reported challenges.</p>
<p>The methodological contribution of this review lies in its systematic comparison of diverse ML algorithms across multiple disease domains. Algorithms analyzed included random forest (42% of studies), logistic regression (37%), support vector machines (32%), XGBoost (21%), artificial neural networks (19%), and decision trees (16%), among others. The review also documented novel techniques, such as deep neural networks and natural language processing (NLP) applied to unstructured EHR text, which represent cutting-edge approaches in the field. Furthermore, the categorization of studies by disease type (cardiovascular, cancer, neurological, infectious, etc.) and by RWE source (EHRs, patient registries, wearable devices) provided a structured framework to assess methodological breadth.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Diseases</th>
<th>Studies, n (%)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cardiovascular diseases</td>
<td>19 (33)</td>
</tr>
<tr class="even">
<td>Cancers and tumors</td>
<td>9 (16)</td>
</tr>
<tr class="odd">
<td>Neurological diseases</td>
<td>6 (11)</td>
</tr>
<tr class="even">
<td>Infectious diseases</td>
<td>5 (9)</td>
</tr>
<tr class="odd">
<td>Metabolic diseases</td>
<td>5 (9)</td>
</tr>
<tr class="even">
<td>Spinal diseases</td>
<td>3 (5)</td>
</tr>
<tr class="odd">
<td>Gastrointestinal diseases</td>
<td>2 (4)</td>
</tr>
<tr class="even">
<td>Ocular diseases</td>
<td>2 (4)</td>
</tr>
<tr class="odd">
<td>Respiratory diseases</td>
<td>2 (4)</td>
</tr>
<tr class="even">
<td>Other diseases</td>
<td>4 (7)</td>
</tr>
</tbody>
</table>
<p>Overall, the methods employed are well suited to the research question. By restricting the scope to clinical trials and cohort studies using RWD, the review highlights real-world applicability rather than hypothetical or simulation-based models. The PRISMA framework enhances replicability, while the inclusion of performance metrics allows for comparative evaluation of ML approaches. The innovative integration of gray literature and regulatory documents further strengthens the analysis, positioning this review as a comprehensive map of the current landscape of ML in real-world healthcare.</p>
</section>
<section id="significance-of-the-work" class="level3">
<h3 class="anchored" data-anchor-id="significance-of-the-work">SIGNIFICANCE OF THE WORK</h3>
<p>The findings of the review underscore the substantial but uneven progress of ML in real-world disease prediction and management. The synthesis of 57 studies reveals several key contributions. First, ML methods—particularly ensemble approaches like random forest and gradient boosting—demonstrated strong predictive performance across diverse disease areas. For example, random forest models achieved an AUROC of 0.85 in cardiovascular disease prediction, while support vector machines reached 83% accuracy in cancer prognosis.</p>
<p>Such results highlight the potential of ML to outperform or at least complement traditional statistical models in clinical decision-making. Second, the review provides valuable insights into the distribution of applications. Cardiovascular diseases dominated the field (33% of studies), followed by cancer (16%) and neurological conditions (11%). This distribution reflects the urgent clinical need for predictive tools in high-burden diseases. Importantly, the review also shows that EHRs are the most common source of RWD (68%), with patient registries (26%) and wearable devices (7%) contributing less but offering novel opportunities for continuous and real-time monitoring.</p>
<p>Third, the review identifies four major application areas: disease prediction (35% of studies), clinical decision-making (25%), healthcare outcomes such as quality of life (23%), and survival prediction (19%). This taxonomy illustrates that ML is not only being used for diagnosis but also for optimizing treatment strategies, monitoring patient well-being, and forecasting long-term outcomes—critical dimensions for precision medicine.</p>
<p>The broader significance lies in the recognition of persistent challenges. Approximately 60% of reviewed studies struggled with data quality issues, lack of interpretability, and limited generalizability across diverse patient populations. These limitations are particularly problematic given the ethical stakes of deploying ML in healthcare. The paper highlights emerging solutions such as fairness-aware algorithms, interpretability frameworks like SHAP and LIME, and evolving regulatory guidelines from the FDA and EMA. Yet, it makes clear that more progress is needed to achieve equitable and transparent ML applications.</p>
<p>In the context of the broader field, this work contributes by synthesizing a fragmented body of literature into a coherent overview. Unlike prior reviews that focused narrowly on EHRs or specific diseases, this study spans multiple conditions, data sources, and algorithm types. It also distinguishes itself by emphasizing regulatory and ethical frameworks, an increasingly critical dimension of digital health research. By identifying both the promise and pitfalls of current practices, the review provides a roadmap for future research and policy development. In conclusion, the significance of this work lies not only in cataloging ML applications but also in clarifying the path forward. By bridging technical, clinical, and regulatory perspectives, the review underscores that the future of ML in healthcare will depend on addressing transparency, fairness, and generalizability while harnessing the predictive power of advanced algorithms. This synthesis is therefore highly valuable for clinicians, data scientists, and policymakers alike.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">REFERENCES</h3>
<ol type="1">
<li>Liu F, Panagiotakos D. Real-world data: a brief review of the methods, applications, challenges and opportunities. BMC Med Res Methodol. Nov 05, 2022;22(1):287. [FREE Full text] [doi: 10.1186/s12874-022-01768-6] [Medline: 36335315]</li>
<li>Dang A. Real-world evidence: a primer. Pharmaceut Med. Jan 2023;37(1):25-36. [FREE Full text] [doi: 10.1007/s40290-022-00456-6] [Medline: 36604368]</li>
<li>Klonoff DC. The expanding role of real-world evidence trials in health care decision making. J Diabetes Sci Technol. Jan 2020;14(1):174-179. [FREE Full text] [doi: 10.1177/1932296819832653] [Medline: 30841738]</li>
<li>Junaid SB, Imam AA, Balogun AO, De Silva LC, Surakat Y A, Kumar G, et al.&nbsp;Recent advancements in emerging technologies for healthcare management systems: a survey. Healthcare (Basel). Oct 03, 2022;10(10):1940. [FREE Full text] [doi: 10.3390/healthcare10101940] [Medline: 36292387]</li>
<li>Williamson SM, Prybutok V . Balancing privacy and progress: a review of privacy challenges, systemic oversight, and</li>
<li>patient perceptions in AI-driven healthcare. Appl Sci. Jan 12, 2024;14(2):675. [doi: 10.3390/app14020675] Derman BA, Belli AJ, Battiwalla M, Hamadani M, Kansagra A, Lazarus HM, et al.</li>
</ol>
<div data-align="right">
<p>Madhu Kiran Reddy Koduru</p>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>